
참고: 
https://github.com/pg-server-study/spring-study/tree/main/JH/chapter1

## 스프링과 오브젝트
스프링은 Java를 기반으로 한 기술이다.
스프링이 자바에서 가장 중요하게 가치를 두는 것은 바로 OOP가 가능한 언어라는 점이다.

그래서 스프링이 가장 관심을 많이 두는 대상은 오브젝트다.


## 관심사의 분리

어떻게 변경이 일어날 때 필요한 작업을 최소화하고 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있었을까?
그것은 분리와 확장을 고려한 설계가 있었기 때문이다.

문제는, 변화는 대체로 한가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다.


토비의 스프링 1장 66p...
[초난감 DAO](https://github.com/pg-server-study/spring-study/tree/main/JH/chapter1#134-%EC%9B%90%EC%B9%99%EA%B3%BC-%ED%8C%A8%ED%84%B4)

이렇게 한 코드에 **여러 관심사항**이 존재하는 것은 많은 **중복** 코드를 야기하며, 훗날 **변경이 일어나게 된다면** 놓치는 부분이 생길 수 있으며 굉장히 지저분한 코드가 된다.

**변화는 먼 미래에만 있는 게 아니다. 며칠 내에, 때론 몇 시간 후에 변화에 대한 요구가 갑자기 발생할 수 있다.**


## 상속과 합성
![](https://jinjungs.github.io/img/tobi-spring/1-1/4DEE3FB2-EE6F-43A8-A476-794A3ACF7783.jpeg)
상속을 통한 확장 방법의 문제점 : 슈퍼-서브 클래스간의 관계가 너무 밀접.
슈퍼 클래스 내부의 변경이 발생할 때 서브 클래스에 변경이 확상되거나 다시 개발해야 하는 문제.


토비의 스프링 1장 84p...


## OCP 
[초난감 DAO](https://github.com/pg-server-study/spring-study/tree/main/JH/chapter1#134-%EC%9B%90%EC%B9%99%EA%B3%BC-%ED%8C%A8%ED%84%B4)가 OCP를 따르지 못했던 이유는?

DB 연결 방법을 확장하고자 하면 DAO 내부도 변경되어야 함.


[변경된 UserDao](https://github.com/pg-server-study/spring-study/tree/main/JH/chapter1#134-%EC%9B%90%EC%B9%99%EA%B3%BC-%ED%8C%A8%ED%84%B4) UML:
![](https://velog.velcdn.com/images/taesunpark/post/d08890d6-2db4-43ee-9489-af0734bb2e1e/image.png)


DB 연결 역할을 ConnectionMaker 객체(인터페이스)로써 분리하고 UserDao와 합성을 한 모습.
DB 연결을 위임하기 때문에 UserDao 입장에서는 DB 연결 방법 변경에 영향 받지 않는다.

즉 확장에 열려있는 반면 이용하는 클라이언트 클래스(UserDao) 입장에서는 변경이 일어나지 않음.



## 높은 응집도와 낮은 결합도

OCP는 높은 응집도와 낮은 결합도 원리로도 설명이 가능하다.
응집도가 높다는건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.

### 높은 응집도

= 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것

만약 모듈의 일부분에만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하는지 파악해야 함.
다른 부분에는 영향을 미치지 않는지 확인해야 하는 이중의 부담이 생김

인터페이스를 상속하는 방식으로 ConnectionMaker을 만들었기 때문에,
기존의 구현체를 수정한다면 해당 구현체의 전체를 고려해 수정하면 되고 기능이 추가된다면 구현체를 통째로 추가하면 된다는 얘기.

즉 작업의 변경 대상이 명확하다

만약 새로운 구현체 XConnectionMaker을 구현해야 한다고 할 때, 인터페이스를 포함해서 다른 구현체들은 테스트할 필요가 없다.
이는 ConnectionMaker을 분리하여 응집도를 높인 덕분이다.


### 낮은 결합도

오브젝트간의 느슨한 연결을 유지하는 것이 바람직하다.

느슨한 연결 = 관계를 유지하는데 꼭 필요한 최소한만 제공하고, 나머지는 서로 독립적이고 알 필요도 없도록 하는 것

=> 변화에 대응하는 속도가 높아지고 확장 용이

결합도 = 어떤 오브젝트에 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도

## 전략 패턴


# 제어의 역전

## 제어의 역전이란?
프로그램의 제어 흐름 구조가 뒤바끼는 것.
오브젝트들은 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다.   

또 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.

## 예시
### Servlet
서블릿의 실행을 개발자가 직접 제어하는 방법은 없다. 대신 서블릿의 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스를 만들고 그 안의 메서드를 호출한다.

### 템플릿 메서드 패턴
템플릿 메서드 패턴에서 제어권은 상위 템플릿 메서드에 있다. 서브 클래스에서 구현되는 훅 메서드들은 언제 어떻게 사용될지 자신은 모른다.

자신은 필요할 때 호출되어 사용되도록 하는 것.
여기서 제어의 역전 개념을 발견할 수 있다.

## 라이브러리와 프레임워크의 차이

토비의 스프링 93p...  
라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.  
반면에 프레임워크는 거구로 애플리케이션 코드가 프레임워크에 의해 사용된다.

프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 한다.  
애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.

[DaoFactory](https://github.com/pg-server-study/spring-study/blob/main/JH/chapter1/README.md#14-%EC%A0%9C%EC%96%B4%EC%99%80-%EC%97%AD%EC%A0%84) 에도 제어의 역전이 적용되어 있다.  
원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었다.
그런데 지금은 DaoFactory에게 있다.

자신이 어떤 ConnectionMaker을 만들고 사용할지 결정할 권한을 DaoFactory에게 넘겼으니 이제 UserDao는 수동적인 존재가 됐다.

자연스럽게 관심사를 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 DaoFactory를 도입했던 과정이 바로 IoC를 적용하는 작업이었다고 볼 수 있다.

## 스프링의 IoC

스프링은 매우 많은 기능을 제공하고 애플리케이션의 다양한 영역과 기술에 관여한다.
하지만 스프링의 핵심을 담당하는 건, 바로 빈 팩토리 또는 애플리케이션 컨텍스트이다.

스프링에서는 스프링이 제어권을 갖고 직접 만들고 관계를 부여하는 오브젝트를 빈(애플리케이션 컴포넌트)이라고 부른다.

스프링 빈은 스프링 컨테이너가 생성, 관계 설정, 사용 등을 제어해주는 제어의 역전이 적용된 객체를 가리키는 말이다.  


토비 스프링 98p..  
그렇다면 굳이 스프링을 사용하지 않고 그냥 [DaoFactory](https://github.com/pg-server-study/spring-study/blob/main/JH/chapter1/README.md#14-%EC%A0%9C%EC%96%B4%EC%99%80-%EC%97%AD%EC%A0%84)와 같은 객체 팩토리를 만들어서 사용하면 되는게 아닐까?

그렇지 않다.  
스프링은 DaoFactory를 통해서는 얻을 수 없는 방대한 기능과 활용 방법을 제공해준다.

## 애플리케이션 컨텍스트

애플리케이션 컨텍스트를 사용하는 이유는 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위해서다.

### 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
팩토리 클래스를 사용한다면 클라이언트는 어떤 팩토리 클래스를 사용해야 하는지 알아야 하고, 필요할 때마다 팩토리 오브젝트를 생성해야 하는 번거로움이 있음.

애플리케이션 컨텍스트를 사용하면 일관된 방법으로 원하는 객체를 가져올 수 있다.

YML처럼 단순한 방법을 사용해 애플리케이션 컨텍스트가 사용할 IoC 설정 정보를 만들 수도 있다.

### 종합 IoC 서비스 제공

애플리케이션 컨텍스트의 역할은 오브젝트 생성, 관계 설정 외에도 오브젝트의 생성 방식, 시점, 전략을 다르게 가져가게 할 수 있다.

부가적으로 자동 생성, 오브젝트 후처리, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.

### 빈을 검색하는 다양한 방법 제공

