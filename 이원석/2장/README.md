# 단위 테스트

## Why

**관심사의 분리**의 원리가 테스트에도 적용된다.  
테스트하고자 하는 대상과 의도가 명확하다면, 그 대상에만 집중해서 테스트하는 것이 바람직하다.   
그렇지 않으면 테스트 수행 과정이 복잡해지고 오류 발생시 정확한 원인을 찾기가 힘들어진다.   

통합 테스트부터 하게 되면 문제의 원인을 찾기가 힘들다. 
그런데 각 단위별로 테스트를 먼저 모두 진행한 뒤라면 어떨까?  
오류 원인의 범위가 대폭 줄어들게 된다.  

단위 테스트를 하는 이유는, 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다. 이때 확인의 대상과 조건이 간단하고 명확할수록 좋다.  
그래서 작은 단위로 제한해서 테스트하는 것이 편리하다.  

## What
단위 테스트 = 작은 단위의 코드에 대해 테스트를 수행하는 것.  

### 단위에 대하여
여기서 단위란 딱 정해진 것은 아니다.  
하나의 객체일 수도, 하나의 메서드일 수도 있다.   

일반적으로 단위는 작을수록 좋다.  
단위를 넘어서는 다른 코드들과 별개로 테스트가 동작할 수 있으면 좋다.   


### DB(외부 리소스)가 쓰이면 단위 테스트가 아니다?

희조님의 말씀이 생각난다. DB를 쓰면 일종의 통합테스트라고 했다.   
그러나 토비는 반대한다.  

사용할 **DB의 상태를 테스트가 관장하고 있다면 이는 단위 테스트라고 할 수 있다**.  
가령 테스트 메서드 동작 전마다 DB 상태를 초기화하거나 모든 테이블을 비워준다면 DB의 상태를 관장하고 있고 이는 단위 테스트이다.  

다만 DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면 그때는 단위 테스트로써의 가치가 없어진다.   

즉, **통제할 수 없는 외부 리소스에 의존하는 테스트는 단위 테스트가 아니다**.  


### 일관성

단위 테스트는 항상 일관성 있는 결과가 보장되어야 한다.  

외부 환경에 영향을 받지 말아야 하며, 테스트 실행 순서를 바꿔도 동일한 결과가 보장되어야 한다.   


# 테스트

## JUnit

Java 진영의 테스트 프레임워크.

즉 IoC가 적용된다.  
다른 프레임워크와 마찬가지로, 테스트 프레임워크에서 동작하는 코드는 main 메서드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.  


## 픽스처

테스트를 수행하는 데 필요한 정보나 오브젝트.  
일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 `@Before` 메서드를 이용해 생성해두면 편리하다.  

## 테스트를 위한 애플리케이션 컨텍스트 관리  

### 애플리케이션 컨텍스트의 생성 비용

빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다.   
애플리케이션 컨텍스트가 생성될 때는 모든 싱글톤 빈 객체를 초기화한다.  

다행히 애플리케이션 컨텍스트는 초기화되고 나면 내부 상태가 바뀌는 일은 거의 없다.  
빈은 싱글톤으로 만들었기 때문에 상태를 갖지 않는다.  

### Autowired
`@Autowired` 가 붙은 인스턴스 변수가 있으면, 변수 타입과 일치하는 애플리케이션 컨텍스트 내의 빈을 찾고 주입해준다.  

일반적으로 DI를 위해선 생성자나 수정자와 같은 메서드가 필요한데, 이 경우에는 메서드가 없어도 주입이 가능하다.   

또한 별도의 DI 설정 없이 빈을 자동으로 가져오게 된다.  
이런 방법을 타입에 의한 자동 와이어링이라고 한다.  

그런데 애플리케이션 컨텍스트 자체가 DI됐다.  
그 이유는 스프링 애플리케이션 컨텍스트가 초기화할 때 자기 자신도 빈으로 등록하기 때문이다.   
